use std::vec;

use risc0_zkvm::{default_prover, ExecutorEnv, ProveInfo, ProverOpts};

// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use axe::{AXE_PROGRAM_ELF, AXE_PROGRAM_ID};
use pow::{POW_PROGRAM_ELF, POW_PROGRAM_ID};
use stone::{STONE_PROGRAM_ELF, STONE_PROGRAM_ID};
use wood::{WOOD_PROGRAM_ELF, WOOD_PROGRAM_ID};

use common::{difficulty, Object, ObjectInput, ObjectOutput};
use pow_program::{PowIn, PowOut};
use utils::ObjectJson;

use axe_program::constants::{AXE_BLUEPRINT, AXE_MINING_MAX};
use stone_program::constants::{STONE_BLUEPRINT, STONE_MINING_MAX};
use wood_program::constants::{WOOD_BLUEPRINT, WOOD_MINING_MAX};

fn mine_object(blueprint: &str, max_difficulty: u64, inputs: Vec<String>) -> (Object, String) {
    let key = {
        let bytes: [u8; 32] = rand::random();
        hex::encode(bytes)
    };

    for seed in 0u32..=u32::MAX {
        let obj = Object {
            key: key.clone(),
            inputs: inputs.clone(),
            seed,
            blueprint: blueprint.to_string(),
        };

        let h = obj.hash();
        if difficulty(&h) <= max_difficulty {
            return (obj, h);
        }
    }

    panic!("failed to mine {} object", blueprint);
}

fn create_pow_proof(
    prover: &impl risc0_zkvm::Prover,
    prover_opts: &ProverOpts,
    n_iters: u32,
    input: String,
) -> (PowOut, ProveInfo) {
    let input = &PowIn { n_iters, input };
    let env = ExecutorEnv::builder()
        .write(&input)
        .unwrap()
        .build()
        .unwrap();

    let pow_proof = prover
        .prove_with_opts(env, POW_PROGRAM_ELF, prover_opts)
        .unwrap();

    pow_proof.receipt.verify(POW_PROGRAM_ID).unwrap();

    let pow_out: PowOut = pow_proof.receipt.journal.decode().unwrap();

    (pow_out, pow_proof)
}

fn create_stone_object(prover: &impl risc0_zkvm::Prover, prover_opts: &ProverOpts) -> ObjectJson {
    let (obj, obj_hash) = mine_object(STONE_BLUEPRINT, STONE_MINING_MAX, vec![]);
    println!("Mined stone: seed={}, hash={}", obj.seed, obj_hash);

    println!("Creating POW proof for stone...");
    let (pow_out, pow_proof) = create_pow_proof(prover, &prover_opts, 3, obj_hash);
    println!("Completed POW proof for stone, {}.", pow_out.output.clone());

    let input = &ObjectInput {
        object: obj.clone(),
        work: pow_out.output.clone(),
    };
    let env = ExecutorEnv::builder()
        // add_assumption makes the receipt to be verified available to the prover.
        .add_assumption(pow_proof.receipt.clone())
        .write(&input)
        .unwrap()
        .write(&pow_out)
        .unwrap()
        .build()
        .unwrap();

    let start = std::time::Instant::now();
    let stone_proof = prover
        .prove_with_opts(env, STONE_PROGRAM_ELF, prover_opts)
        .unwrap();
    let duration = start.elapsed();
    println!("Stone proving time: {:?}", duration);

    stone_proof.receipt.verify(STONE_PROGRAM_ID).unwrap();

    let committed_output: ObjectOutput = stone_proof.receipt.journal.decode().unwrap();
    println!("Stone committed hash: {}", committed_output.hash);

    ObjectJson {
        object: obj,
        hash: committed_output.hash,
        work: pow_out.output.clone(),
        proof: stone_proof.receipt,
        program_vk: STONE_PROGRAM_ID,
    }
}

fn create_wood_object(prover: &impl risc0_zkvm::Prover, prover_opts: &ProverOpts) -> ObjectJson {
    let (obj, obj_hash) = mine_object(WOOD_BLUEPRINT, WOOD_MINING_MAX, vec![]);
    println!("Mined wood: seed={}, hash={}", obj.seed, obj_hash);

    let input = &ObjectInput {
        object: obj.clone(),
        work: hex::encode([0u8; 32]),
    };
    let env = ExecutorEnv::builder()
        .write(&input)
        .unwrap()
        .build()
        .unwrap();

    let start = std::time::Instant::now();
    let wood_proof = prover
        .prove_with_opts(env, WOOD_PROGRAM_ELF, prover_opts)
        .unwrap();
    let duration = start.elapsed();
    println!("Wood proving time: {:?}", duration);

    // let start = std::time::Instant::now();
    // let groth16_receipt = prover
    //     .compress(&ProverOpts::groth16(), &wood_proof.receipt)
    //     .unwrap();
    // let duration = start.elapsed();
    // println!("Wood proof compression time: {:?}", duration);

    wood_proof.receipt.verify(WOOD_PROGRAM_ID).unwrap();

    let committed_output: ObjectOutput = wood_proof.receipt.journal.decode().unwrap();
    println!("Wood committed hash: {}", committed_output.hash);

    ObjectJson {
        object: obj,
        hash: committed_output.hash,
        work: hex::encode([0u8; 32]),
        proof: wood_proof.receipt,
        program_vk: WOOD_PROGRAM_ID,
    }
}

fn create_axe_object(
    prover: &impl risc0_zkvm::Prover,
    prover_opts: &ProverOpts,
    wood_object: ObjectJson,
    stone_object: ObjectJson,
) -> ObjectJson {
    let (obj, obj_hash) = mine_object(
        AXE_BLUEPRINT,
        AXE_MINING_MAX,
        vec![wood_object.hash.clone(), stone_object.hash.clone()],
    );
    println!("Created axe: seed={}, hash={}", obj.seed, obj_hash);

    let input = &ObjectInput {
        object: obj.clone(),
        work: hex::encode([0u8; 32]),
    };

    let wood_output: ObjectOutput = wood_object.proof.journal.decode().unwrap();
    let stone_output: ObjectOutput = stone_object.proof.journal.decode().unwrap();

    let env = ExecutorEnv::builder()
        .write(&input)
        .unwrap()
        .add_assumption(wood_object.proof.clone())
        .write(&wood_output)
        .unwrap()
        .add_assumption(stone_object.proof.clone())
        .write(&stone_output)
        .unwrap()
        .build()
        .unwrap();

    let start = std::time::Instant::now();
    let axe_proof = prover
        .prove_with_opts(env, AXE_PROGRAM_ELF, prover_opts)
        .unwrap();
    let duration = start.elapsed();
    println!("Axe proving time: {:?}", duration);

    axe_proof.receipt.verify(AXE_PROGRAM_ID).unwrap();

    let committed_output: ObjectOutput = axe_proof.receipt.journal.decode().unwrap();
    println!("Axe committed hash: {}", committed_output.hash);

    ObjectJson {
        object: obj,
        hash: committed_output.hash,
        work: hex::encode([0u8; 32]),
        proof: axe_proof.receipt,
        program_vk: AXE_PROGRAM_ID,
    }
}

fn main() {
    // Initialize tracing. In order to view logs, run `RUST_LOG=info cargo run`
    tracing_subscriber::fmt()
        .with_env_filter(tracing_subscriber::filter::EnvFilter::from_default_env())
        .init();

    std::fs::create_dir_all("objects").expect("failed to create objects directory");

    // Obtain the default prover.
    let prover = default_prover();
    let prover_opts = ProverOpts::succinct();

    println!("pow program id {:?}", POW_PROGRAM_ID);
    println!("wood program id {:?}", WOOD_PROGRAM_ID);
    println!("stone program id {:?}", STONE_PROGRAM_ID);
    println!("axe program id {:?}", AXE_PROGRAM_ID);

    let mut wood_objects = Vec::new();
    let mut stone_objects = Vec::new();

    let start = std::time::Instant::now();
    println!("\n=== Creating Wood ===",);
    let object = create_wood_object(&prover, &prover_opts);
    let filename = format!("objects/wood_1.json");
    object.save_as_json(&filename).expect("failed to save wood");
    println!("Saved to {}", filename);
    wood_objects.push(object);
    let duration = start.elapsed();
    println!("\nTotal wood creation time: {:?}", duration);

    let start = std::time::Instant::now();
    println!("\n=== Creating Stone ===");
    let object = create_stone_object(&prover, &prover_opts);
    let filename = format!("objects/stone_1.json");
    object
        .save_as_json(&filename)
        .expect("failed to save stone");
    println!("Saved to {}", filename);
    stone_objects.push(object);
    let duration = start.elapsed();
    println!("\nTotal stone creation time: {:?}", duration);

    let start = std::time::Instant::now();
    println!("\n=== Creating Axe===");
    let wood_object = wood_objects.pop().expect("need wood for axe");
    let stone_object = stone_objects.pop().expect("need stone for axe");

    let object = create_axe_object(&prover, &prover_opts, wood_object, stone_object);
    let filename = format!("objects/axe_1.json");
    object.save_as_json(&filename).expect("failed to save axe");
    println!("Saved to {}", filename);
    let duration = start.elapsed();
    println!("\nTotal axe creation time: {:?}", duration);

    println!("\nâœ“ All objects created successfully!");
}
